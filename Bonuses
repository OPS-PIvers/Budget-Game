/**
 * Bonuses and Streak Calculations for Budget Game v3
 * Handles streak point calculation and weekly threshold bonuses.
 * Includes corrected regex in trackActivityStreaks.
 */

/**
 * Calculates the point multiplier and bonus points for an activity based on streak length.
 * Uses thresholds and bonus points defined in CONFIG.
 * @param {string} activityName The name of the activity.
 * @param {number} activityPoints The base points for the activity.
 * @return {object} { originalPoints, bonusPoints, totalPoints, streakLength, multiplier }
 */
function calculateStreakMultiplier(activityName, activityPoints) {
  // Get the current activity streaks
  // Assumes trackActivityStreaks() is functional and accessible
  let streakLength = 0;
  try {
    // Check if trackActivityStreaks exists before calling
    if (typeof trackActivityStreaks === "function") {
       const streakData = trackActivityStreaks(); // Needs to be implemented correctly
       streakLength = (streakData.streaks && streakData.streaks[activityName]) || (streakData.buildingStreaks && streakData.buildingStreaks[activityName]) || 0;
    } else {
       Logger.log("Warning: trackActivityStreaks function not found in calculateStreakMultiplier. Assuming 0 streak.");
       streakLength = 0;
    }
  } catch (e) {
     Logger.log(`Error getting streak data for ${activityName} in calculateStreakMultiplier: ${e}. Assuming 0 streak.`);
     streakLength = 0;
  }

  let bonusPoints = 0; // This is the FLAT bonus added ON TOP of multiplier
  let multiplier = 1; // Base multiplier

  // Check thresholds from CONFIG, highest first
  if (streakLength >= CONFIG.STREAK_THRESHOLDS.MULTIPLIER) {
    multiplier = 2; // Double points
    bonusPoints = 0; // No flat bonus if multiplier is active
  } else if (streakLength >= CONFIG.STREAK_THRESHOLDS.BONUS_2) {
    bonusPoints = CONFIG.STREAK_BONUS_POINTS.BONUS_2; // e.g., +2 points
  } else if (streakLength >= CONFIG.STREAK_THRESHOLDS.BONUS_1) {
    bonusPoints = CONFIG.STREAK_BONUS_POINTS.BONUS_1; // e.g., +1 point
  }

  // Calculate total points: (Base * Multiplier) + Flat Bonus
  const totalPoints = (activityPoints * multiplier) + bonusPoints;

  return {
    originalPoints: activityPoints,
    bonusPoints: bonusPoints, // This is the *additional* flat bonus
    totalPoints: totalPoints,
    streakLength: streakLength,
    multiplier: multiplier
  };
}

/**
 * Tracks activity streaks for a specific household with improved streak detection and logging.
 * @param {string} householdId - The household ID
 * @return {Object} Object containing streaks and buildingStreaks objects
 */
function trackActivityStreaksForHousehold(householdId) {
  const buildingStreaks = {}; // 2 days ending yesterday
  const fullStreaks = {};     // 3+ days, potentially including today
  const DEBUG_ACTIVITY = "Get 7+ hours of sleep"; // Activity to focus logging on

  // Diagnostic Log: Start
  Logger.log(`trackActivityStreaksForHousehold: Started for ID ${householdId}.`);

  try {
    if (!householdId) {
      Logger.log("trackActivityStreaksForHousehold: No household ID provided. Falling back to global streaks.");
      return trackActivityStreaks(); // Fall back to regular function
    }

    // Get household emails
    const householdEmails = getHouseholdEmails(householdId);

    // If no emails found for the ID (e.g., invalid ID), fall back
    if (!householdEmails || householdEmails.length === 0) {
      Logger.log(`trackActivityStreaksForHousehold: No emails found for household ID ${householdId}. Falling back to global streaks.`);
      return trackActivityStreaks();
    }
    Logger.log(`trackActivityStreaksForHousehold: Found ${householdEmails.length} emails for household ID ${householdId}.`);

    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);

    if (!dashboardSheet) {
      Logger.log("trackActivityStreaksForHousehold: Dashboard sheet not found. Returning empty streaks.");
      return { buildingStreaks, streaks: fullStreaks };
    }

    const lastRow = dashboardSheet.getLastRow();
    if (lastRow <= 1) {
      Logger.log("trackActivityStreaksForHousehold: No data on Dashboard to track streaks.");
      return { buildingStreaks, streaks: fullStreaks };
    }

    // Fetch history (Columns A, B, C and potentially Email Column)
    // We need to find the email column reliably first.
    const headerRow = dashboardSheet.getRange(1, 1, 1, dashboardSheet.getLastColumn()).getValues()[0];
    let emailColumnIndex = -1;
    for (let i = 0; i < headerRow.length; i++) {
        // Assuming the header is exactly "Email" (case-insensitive check)
        if (headerRow[i] && headerRow[i].toString().trim().toLowerCase() === 'email') {
            emailColumnIndex = i;
            break;
        }
    }
    Logger.log(`trackActivityStreaksForHousehold: Email column index identified as ${emailColumnIndex} (0-based).`);

    // Fetch necessary columns: A (Date), C (Activities), and Email Column (if found)
    const colsToFetch = [1, 3]; // Date, Activities
    if (emailColumnIndex !== -1) {
      colsToFetch.push(emailColumnIndex + 1); // Add email column number (1-based for range)
    }

    // Use getRecentDashboardData helper but modify it slightly or redo logic here
    // Let's redo logic here for clarity with email filtering
    const daysToFetch = 30;
    const endRow = dashboardSheet.getLastRow();
    const startRow = Math.max(2, endRow - (daysToFetch * 2) + 1); // Fetch ample data
    const numRows = endRow - startRow + 1;
    const rawData = dashboardSheet.getRange(startRow, 1, numRows, dashboardSheet.getLastColumn()).getValues();

    // Filter history by date and household email
    const history = [];
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysToFetch + 1);
    cutoffDate.setHours(0, 0, 0, 0);

    rawData.forEach(row => {
        const date = row[0];
        if (!(date instanceof Date) || date < cutoffDate) return; // Skip invalid/old dates

        let includeRow = false;
        if (emailColumnIndex === -1) {
            // If no email column detected, include all rows (historical data assumption)
            includeRow = true;
        } else {
            const rowEmail = row[emailColumnIndex] || "";
            if (householdEmails.some(e => e.toLowerCase() === rowEmail.toString().toLowerCase())) {
                includeRow = true;
            }
        }

        if (includeRow) {
            // Push only the necessary columns [Date, Activities]
            history.push([row[0], row[2]]);
        }
    });


    if (history.length === 0) {
       Logger.log(`trackActivityStreaksForHousehold: No recent history found for household ID ${householdId}.`);
       return { buildingStreaks, streaks: fullStreaks };
    }
    Logger.log(`trackActivityStreaksForHousehold: Filtered history count for household: ${history.length}.`);


    const activityData = getActivityDataCached(); // For checking if activity exists
    const activityDates = {}; // { activityName: Set{'YYYY-MM-DD', ... } }

    // Populate activityDates map (using filtered history)
    history.forEach((row, index) => {
      const date = row[0];
      const activitiesStr = row[1] || ""; // Activities string is now index 1
      const formattedDate = formatDateYMD(date);

      if (activitiesStr) {
        const activitiesList = activitiesStr.split(", ");
        activitiesList.forEach(activityEntry => {
          // Use the same robust regex as in trackActivityStreaks
          const match = activityEntry.match(/^[âž•âž–]\s(.*?)\s*(?:\(ðŸ”¥\d+\))?\s*\(([+-]\d+)\)/);

          if (match && match[1]) {
            const activityName = match[1].trim();

            // Specific Log for Debug Activity
            if (activityName === DEBUG_ACTIVITY) {
              Logger.log(`trackActivityStreaksForHousehold: Found '${DEBUG_ACTIVITY}' on ${formattedDate} in history row ${index}. Checking eligibility...`);
            }

            // Only track POSITIVE base activities
            if (activityData.pointValues[activityName] !== undefined && activityData.pointValues[activityName] > 0) {
              if (!activityDates[activityName]) {
                activityDates[activityName] = new Set();
              }
              activityDates[activityName].add(formattedDate);
              if (activityName === DEBUG_ACTIVITY) {
                Logger.log(`  -> Added date ${formattedDate} for '${DEBUG_ACTIVITY}'.`);
              }
            } else {
              if (activityName === DEBUG_ACTIVITY) {
                Logger.log(`  -> Skipped '${DEBUG_ACTIVITY}' found on ${formattedDate} (points: ${activityData.pointValues[activityName]})`);
              }
            }
          }
        });
      }
    });

    // Log collected dates for the debug activity
    const debugDates = activityDates[DEBUG_ACTIVITY] ? Array.from(activityDates[DEBUG_ACTIVITY]).sort() : [];
    Logger.log(`trackActivityStreaksForHousehold: Collected dates for '${DEBUG_ACTIVITY}': ${JSON.stringify(debugDates)}`);

    // Calculate streaks (same logic as trackActivityStreaks)
    const today = new Date();
    const formattedToday = formatDateYMD(today);

    for (const activityName in activityDates) {
      const dateSet = activityDates[activityName];
      const sortedDates = Array.from(dateSet).sort();

      if (activityName === DEBUG_ACTIVITY) {
        Logger.log(`trackActivityStreaksForHousehold: Calculating streak for '${DEBUG_ACTIVITY}'. Sorted Dates: ${JSON.stringify(sortedDates)}`);
      }

      if (sortedDates.length < 2) continue;

      let currentStreak = 0;
      let latestStreakLength = 0;
      let latestStreakEndDateStr = null;

      for(let i = sortedDates.length - 1; i >= 0; i--) {
        const currentDateStr = sortedDates[i];
        let prevDateStrInLoop = null;
        let diffDays = null;

        if (i === sortedDates.length - 1) {
           currentStreak = 1;
           latestStreakEndDateStr = currentDateStr;
        } else {
           prevDateStrInLoop = sortedDates[i+1];
           const currentDateUTC = new Date(Date.UTC(parseInt(currentDateStr.substring(0,4)), parseInt(currentDateStr.substring(5,7))-1, parseInt(currentDateStr.substring(8,10))));
           const prevDateUTC = new Date(Date.UTC(parseInt(prevDateStrInLoop.substring(0,4)), parseInt(prevDateStrInLoop.substring(5,7))-1, parseInt(prevDateStrInLoop.substring(8,10))));
           diffDays = (prevDateUTC - currentDateUTC) / (1000 * 60 * 60 * 24);

           if (diffDays === 1) {
              currentStreak++;
           } else {
              break;
           }
        }
        if (activityName === DEBUG_ACTIVITY) {
           Logger.log(`  -> Loop i=${i}: Date=${currentDateStr}, PrevDate=${prevDateStrInLoop}, Diff=${diffDays}, currentStreak=${currentStreak}`);
        }
      }
      latestStreakLength = currentStreak;

      if (activityName === DEBUG_ACTIVITY) {
        Logger.log(`trackActivityStreaksForHousehold: Final calc for '${DEBUG_ACTIVITY}': Length=${latestStreakLength}, EndDate=${latestStreakEndDateStr}`);
      }

      if (latestStreakEndDateStr) {
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        const formattedYesterday = formatDateYMD(yesterday);

        if (activityName === DEBUG_ACTIVITY) {
           Logger.log(`  -> Checking if streak is active: EndDate=${latestStreakEndDateStr}, Today=${formattedToday}, Yesterday=${formattedYesterday}`);
        }

        if (latestStreakEndDateStr === formattedToday || latestStreakEndDateStr === formattedYesterday) {
           if (latestStreakLength >= 3) {
              fullStreaks[activityName] = latestStreakLength;
              if (activityName === DEBUG_ACTIVITY) Logger.log(`  -> Added to fullStreaks.`);
           } else if (latestStreakLength === 2 && latestStreakEndDateStr === formattedYesterday) {
               buildingStreaks[activityName] = 2;
               if (activityName === DEBUG_ACTIVITY) Logger.log(`  -> Added to buildingStreaks.`);
           }
        } else {
           if (activityName === DEBUG_ACTIVITY) Logger.log(`  -> Streak ending ${latestStreakEndDateStr} is not active today/yesterday.`);
        }
      }
    }

    // Final Result Log
    Logger.log(`trackActivityStreaksForHousehold FINAL result (Household ${householdId}): building=${Object.keys(buildingStreaks).length}, full=${Object.keys(fullStreaks).length}`);
    Logger.log("Full Result: " + JSON.stringify({ buildingStreaks, streaks: fullStreaks }));

    return { buildingStreaks, streaks: fullStreaks };

  } catch (error) {
    Logger.log(`CRITICAL ERROR in trackActivityStreaksForHousehold (Household ${householdId}): ${error}`);
    Logger.log(`Stack: ${error.stack}`);
    return { buildingStreaks: {}, streaks: {} }; // Return empty on error
  }
}

// ActivityProcessing.gs
// Place this function within the ActivityProcessing.gs file, replacing the existing trackActivityStreaks

/**
 * Tracks activity streaks by analyzing past activity data from the Dashboard.
 * Returns objects detailing current building (2-day) and full (3+ day) streaks.
 * Uses a more robust regex and includes targeted logging.
 * @return {object} { buildingStreaks: { activityName: 2 }, streaks: { activityName: days } }
 */
function trackActivityStreaks() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
  const buildingStreaks = {}; // 2 days ending yesterday
  const fullStreaks = {};     // 3+ days, potentially including today
  const DEBUG_ACTIVITY = "Get 7+ hours of sleep"; // Activity to focus logging on

  // Diagnostic Log: Start
  Logger.log("trackActivityStreaks: Function started.");

  if (!dashboardSheet) {
    Logger.log("trackActivityStreaks: Dashboard sheet not found. Returning empty streaks.");
    return { buildingStreaks, streaks: fullStreaks };
  }

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow <= 1) {
     Logger.log("trackActivityStreaks: No data on Dashboard to track streaks.");
     return { buildingStreaks, streaks: fullStreaks };
  }

  // Use helper function to get recent data (Date, Points, Activities String)
  // Ensure getRecentDashboardData fetches columns A, B, C correctly.
  const daysToFetch = 30; // Fetch enough history for longest streaks
  const history = typeof getRecentDashboardData === "function" ? getRecentDashboardData(dashboardSheet, daysToFetch) : [];

  if (history.length === 0) {
     Logger.log("trackActivityStreaks: No recent history found from Dashboard helper function.");
     return { buildingStreaks, streaks: fullStreaks };
  }
  Logger.log(`trackActivityStreaks: Fetched ${history.length} rows of history.`);
  // Log the most recent row's activity string for inspection
  if(history.length > 0) Logger.log(`trackActivityStreaks: Most recent history entry activities: ${history[history.length-1][2]}`);


  const activityData = getActivityDataCached(); // For checking if activity exists
  const activityDates = {}; // { activityName: Set{'YYYY-MM-DD', ... } }

  // Populate activityDates map
  history.forEach((row, index) => {
    const date = row[0];
    const activitiesStr = row[2] || ""; // Column C
    if (!(date instanceof Date)) return; // Skip if date is invalid

    const formattedDate = formatDateYMD(date); // Use helper for consistent YYYY-MM-DD

    if (activitiesStr) {
      const activitiesList = activitiesStr.split(", ");
      activitiesList.forEach(activityEntry => {
        // --- ROBUST REGEX ---
        // Matches symbol (âž• or âž–), captures activity name (non-greedy),
        // optionally matches streak text (non-capturing), matches points.
        const match = activityEntry.match(/^[âž•âž–]\s(.*?)\s*(?:\(ðŸ”¥\d+\))?\s*\(([+-]\d+)\)/);
        // --- END ROBUST REGEX ---

        if (match && match[1]) {
          const activityName = match[1].trim();
          const points = parseInt(match[2]); // Get points associated with this specific entry

          // *** Specific Log for Debug Activity ***
          if (activityName === DEBUG_ACTIVITY) {
            Logger.log(`trackActivityStreaks: Found '${DEBUG_ACTIVITY}' on ${formattedDate} in history row ${index}. Checking eligibility... Entry: "${activityEntry}"`);
          }

          // Only track streaks for POSITIVE base activities
          // Check if the activity name exists in our reference AND had positive base points
          if (activityData.pointValues[activityName] !== undefined && activityData.pointValues[activityName] > 0) {
            if (!activityDates[activityName]) {
              activityDates[activityName] = new Set(); // Use Set for unique dates per activity
            }
            activityDates[activityName].add(formattedDate);

            // *** Specific Log for Debug Activity ***
            if (activityName === DEBUG_ACTIVITY) {
              Logger.log(`trackActivityStreaks: -> Added date ${formattedDate} for '${DEBUG_ACTIVITY}'.`);
            }
          } else {
             // *** Specific Log for Debug Activity ***
             if (activityName === DEBUG_ACTIVITY) {
               Logger.log(`trackActivityStreaks: -> Skipped '${DEBUG_ACTIVITY}' found on ${formattedDate} because point value is ${activityData.pointValues[activityName]} or undefined.`);
             }
             // Diagnostic Log: Skipped Other Activities (Uncomment if needed)
             // else { Logger.log(`trackActivityStreaks: Skipped "${activityName}" (Points: ${activityData.pointValues[activityName]}) from entry: "${activityEntry}"`); }
          }
        } else {
            // Diagnostic Log: Regex Failures (Uncomment if needed)
            // if (activityEntry.trim()) Logger.log(`trackActivityStreaks: Regex failed for entry: "${activityEntry}"`);
        }
      });
    }
  });

   // Log the collected dates for the specific activity
   const debugDates = activityDates[DEBUG_ACTIVITY] ? Array.from(activityDates[DEBUG_ACTIVITY]).sort() : [];
   Logger.log(`trackActivityStreaks: Collected dates for '${DEBUG_ACTIVITY}': ${JSON.stringify(debugDates)}`);

  // Calculate streaks for each activity found
  const today = new Date();
  const formattedToday = formatDateYMD(today);

  for (const activityName in activityDates) {
    const dateSet = activityDates[activityName];
    const sortedDates = Array.from(dateSet).sort(); // Sort dates chronologically 'YYYY-MM-DD'

    // *** Specific Log for Debug Activity ***
    if (activityName === DEBUG_ACTIVITY) {
       Logger.log(`trackActivityStreaks: Calculating streak for '${DEBUG_ACTIVITY}'. Sorted Dates: ${JSON.stringify(sortedDates)}`);
    }

    if (sortedDates.length < 2) continue; // Need at least 2 days for any streak

    let currentStreak = 0;
    let latestStreakLength = 0;
    let latestStreakEndDateStr = null;

     // Iterate backward from the last logged date for this activity
     for(let i = sortedDates.length - 1; i >= 0; i--) {
        const currentDateStr = sortedDates[i];
        let prevDateStrInLoop = null; // For logging
        let diffDays = null;          // For logging

        if (i === sortedDates.length - 1) { // Start from the most recent date
           currentStreak = 1;
           latestStreakEndDateStr = currentDateStr;
        } else {
           prevDateStrInLoop = sortedDates[i+1]; // The date chronologically AFTER currentDateStr

           // Calculate difference in days using UTC to avoid timezone issues
           const currentDateUTC = new Date(Date.UTC(parseInt(currentDateStr.substring(0,4)), parseInt(currentDateStr.substring(5,7))-1, parseInt(currentDateStr.substring(8,10))));
           const prevDateUTC = new Date(Date.UTC(parseInt(prevDateStrInLoop.substring(0,4)), parseInt(prevDateStrInLoop.substring(5,7))-1, parseInt(prevDateStrInLoop.substring(8,10))));
           diffDays = (prevDateUTC - currentDateUTC) / (1000 * 60 * 60 * 24);

           if (diffDays === 1) {
              currentStreak++; // Dates are consecutive, continue streak backward
           } else {
              break; // Streak broken, stop checking further back for THIS latest streak
           }
        }
        // *** Specific Log for Debug Activity ***
         if (activityName === DEBUG_ACTIVITY) {
            Logger.log(`  -> Loop i=${i}: Date=${currentDateStr}, PrevDate=${prevDateStrInLoop}, Diff=${diffDays}, currentStreak=${currentStreak}`);
         }
     }
     latestStreakLength = currentStreak; // Length of the most recent consecutive block of days

     // *** Specific Log for Debug Activity ***
     if (activityName === DEBUG_ACTIVITY) {
        Logger.log(`trackActivityStreaks: Final calculated streak for '${DEBUG_ACTIVITY}': Length=${latestStreakLength}, EndDate=${latestStreakEndDateStr}`);
     }


     // Categorize the LATEST streak found for this activity
     if (latestStreakEndDateStr) { // Ensure we found at least one date
        // Check if the latest streak includes today OR ended yesterday
        const yesterday = new Date(today);
        yesterday.setDate(today.getDate() - 1);
        const formattedYesterday = formatDateYMD(yesterday);

        // *** Specific Log for Debug Activity ***
        if (activityName === DEBUG_ACTIVITY) {
           Logger.log(`  -> Checking if streak is active: EndDate=${latestStreakEndDateStr}, Today=${formattedToday}, Yesterday=${formattedYesterday}`);
        }

        if (latestStreakEndDateStr === formattedToday || latestStreakEndDateStr === formattedYesterday) {
           // Only consider streaks ending today or yesterday as potentially "active"
           if (latestStreakLength >= 3) {
              fullStreaks[activityName] = latestStreakLength;
              // *** Specific Log for Debug Activity ***
              if (activityName === DEBUG_ACTIVITY) Logger.log(`  -> Added to fullStreaks.`);
           } else if (latestStreakLength === 2 && latestStreakEndDateStr === formattedYesterday) {
               // Only count as "building" if it ended YESTERDAY
               buildingStreaks[activityName] = 2;
               // *** Specific Log for Debug Activity ***
              if (activityName === DEBUG_ACTIVITY) Logger.log(`  -> Added to buildingStreaks.`);
           }
        } else {
            // *** Specific Log for Debug Activity ***
            if (activityName === DEBUG_ACTIVITY) Logger.log(`  -> Streak ending ${latestStreakEndDateStr} is not active today/yesterday.`);
        }
     }
  }

  // Final Diagnostic Log: Result
  Logger.log(`trackActivityStreaks FINAL result: building=${Object.keys(buildingStreaks).length}, full=${Object.keys(fullStreaks).length}`);
  Logger.log("Full Result: " + JSON.stringify({ buildingStreaks, streaks: fullStreaks }));

  return { buildingStreaks, streaks: fullStreaks };
}

// --- End of updated trackActivityStreaks ---


/**
 * Checks if the user qualifies for the weekly grad school alarm bonus.
 * (This is specific, might be removed or generalized later)
 * Reads activity data from the Dashboard sheet for the current week.
 * @return {object} { qualifies: boolean, count: number, bonusPoints: number }
 */
function checkGradSchoolAlarmBonus() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
  // Ensure activity name exactly matches Points Reference and CONFIG if needed
  const targetActivity = "Dedicated study/work block (e.g., Grad School)";
  const requiredCount = 5; // How many times needed per week
  const bonusPointsValue = 2; // Points awarded if qualified

  if (!dashboardSheet) {
     Logger.log("Dashboard sheet not found for Grad School Bonus check.");
     return { qualifies: false, count: 0, bonusPoints: 0 };
  }

  // Check if target activity exists at all
   const activityData = getActivityDataCached();
   if (activityData.pointValues[targetActivity] === undefined) {
    //  Logger.log(`Grad school bonus check skipped: Target activity "${targetActivity}" not found in Points Reference.`);
      return { qualifies: false, count: 0, bonusPoints: 0 };
   }

  const today = new Date();
  const startOfWeek = getWeekStartDate(today);
  const endOfWeek = getWeekEndDate(today);

  // Fetch history for the current week from Dashboard
  // Use the helper function defined in Suggestions.gs
  const history = typeof getRecentDashboardData === "function" ? getRecentDashboardData(dashboardSheet, 7) : [];
  let countThisWeek = 0;

  history.forEach(row => {
    const date = row[0];
    // Check if the date falls within the current week (Sun to Sat)
    if (date >= startOfWeek && date <= endOfWeek) {
      const activitiesStr = row[2] || "";
      // Use regex to count occurrences accurately, allowing for streak text
      const escapedName = targetActivity.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      // Adjusted regex to match the robust format used elsewhere
      const regex = new RegExp(`[âž•âž–]\\s${escapedName}\\s(\\(ðŸ”¥\\d+\\))?\\s\\([+-]`, "g");
      const matches = activitiesStr.match(regex);
      if (matches) {
        countThisWeek += matches.length;
      }
    }
  });

  const qualifies = countThisWeek >= requiredCount;
  const bonusPoints = qualifies ? bonusPointsValue : 0;

  // Logger.log(`Grad School Bonus Check (Current Week): Count=${countThisWeek}, Qualifies=${qualifies}`); // Keep commented unless debugging
  return {
    qualifies: qualifies,
    count: countThisWeek,
    bonusPoints: bonusPoints
  };
}



/**
 * Defines the rules for automatic weekly threshold bonuses.
 * Each object defines a bonus condition and reward.
 * Uses count functions to determine qualification based on weekly data.
 * @return {Array<object>} Array of bonus definition objects.
 */
function getWeeklyThresholdBonuses() {
  return [
    {
      id: "health-enthusiast",
      name: "Health Enthusiast",
      description: "Complete 3+ Health activities",
      category: "Health", // Uses category mapping
      minCount: 3,
      bonusPoints: 5,
      /** @param {object} weekSummary - Summary object { categories: { "Health Activities": count, ... } }.
       *  @param {Array<object>} weekActivities - Detailed activities from getWeekActivities.
       *  @param {object} activityData - Cached activity data. */
      countFunction: function(weekSummary, weekActivities, activityData) {
        // Prefer counting from detailed activities for accuracy
        return weekActivities.filter(act => act.category === 'Health').length; // Use category from act object
      }
    },
    {
      id: "delivery-dodger",
      name: "Delivery Dodger",
      description: "Fewer than 2 food delivery orders",
      specificActivity: "Order food for delivery", // Exact activity name
      maxCount: 1, // Max allowed is 1 (0 or 1 qualifies)
      bonusPoints: 4,
      countFunction: function(weekSummary, weekActivities, activityData) {
        // Filter detailed activities by the specific name defined in 'this' bonus object
        return weekActivities.filter(act => act.name === this.specificActivity).length;
      }
    },
    {
      id: "household-champion",
      name: "Household Champion",
      description: "Complete 5+ Household activities",
      category: "Household",
      minCount: 5,
      bonusPoints: 6,
      countFunction: function(weekSummary, weekActivities, activityData) {
         return weekActivities.filter(act => act.category === 'Household').length; // Use category from act object
      }
    },
    {
      id: "coffee-saver",
      name: "Coffee Saver",
      description: "No Starbucks/coffee purchases",
      specificActivity: "Starbucks/coffee/fast snack", // Exact activity name
      maxCount: 0, // Must be exactly 0
      bonusPoints: 3,
      countFunction: function(weekSummary, weekActivities, activityData) {
        return weekActivities.filter(act => act.name === this.specificActivity).length;
      }
    }
    // Add more bonus definitions here
  ];
}


/**
 * Checks all weekly threshold bonuses based on the *past* week's performance.
 * Should be called typically at the beginning of a new week or in the weekly digest.
 * Uses getWeekActivities (from GoalSetting.gs) to get detailed data.
 * @param {Date} [referenceDate=new Date()] Optional: Date to determine which week to check (defaults to today, checking the week that just ended).
 * @return {object} { earnedBonuses: Array<object>, totalBonusPoints: number }
 */
function calculateWeeklyThresholdBonuses(referenceDate) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const earnedBonuses = [];
  let totalBonusPoints = 0;

  // Determine the week range to check (the week ending *before* referenceDate)
  const checkDate = referenceDate || new Date();
  const endOfWeekToCheck = getWeekStartDate(checkDate); // Start of current week is end of last week + 1ms
  endOfWeekToCheck.setMilliseconds(endOfWeekToCheck.getMilliseconds() - 1); // Go back to Sat 23:59:59.999
  const startOfWeekToCheck = getWeekStartDate(endOfWeekToCheck); // Get Sunday of that week

  Logger.log(`Calculating threshold bonuses for week: ${formatDateYMD(startOfWeekToCheck)} to ${formatDateYMD(endOfWeekToCheck)}`);

  // Get detailed activity data for that specific week using getWeekActivities (from GoalSetting.gs)
  let weekActivities = [];
  if (typeof getWeekActivities === "function") {
      // Get activities for the specific household if enabled, otherwise all activities
      const email = Session.getEffectiveUser().getEmail();
      const householdId = CONFIG.HOUSEHOLD_SETTINGS.ENABLED ? getUserHouseholdId(email) : null;
      const householdEmails = householdId ? getHouseholdEmails(householdId) : [];
      
      // Assuming getWeekActivities takes householdEmails as an optional third parameter
      weekActivities = getWeekActivities(startOfWeekToCheck, endOfWeekToCheck, householdEmails);
      Logger.log(`Fetched ${weekActivities.length} activities for bonus calculation (Household filtered: ${!!householdId})`);
  } else {
      Logger.log("ERROR: getWeekActivities function not found in calculateWeeklyThresholdBonuses.");
      return { earnedBonuses: [], totalBonusPoints: 0 };
  }

  const activityData = getActivityDataCached();

  // Calculate a summary object needed for some count functions (or adapt count functions)
  // Ensure calculateSummaryFromActivities exists in ActivityProcessing.gs or wherever it should be
  let weekSummary = {};
  if (typeof calculateSummaryFromActivities === "function") {
      weekSummary = calculateSummaryFromActivities(weekActivities, activityData);
  } else {
      Logger.log("Warning: calculateSummaryFromActivities function not found.");
      // Create a minimal summary structure if the function is missing
      weekSummary = {
          total: 0, positive: 0, negative: 0, topActivity: "None", topActivityCount: 0,
          categories: {
            "Positive Activities": 0, "Negative Activities": 0,
            "Health Activities": 0, "Household Activities": 0
          }
      };
      // Populate basic counts if possible
      weekSummary.positive = weekActivities.filter(a => a.points >= 0).length;
      weekSummary.negative = weekActivities.filter(a => a.points < 0).length;
      weekSummary.categories["Positive Activities"] = weekSummary.positive;
      weekSummary.categories["Negative Activities"] = weekSummary.negative;
      weekSummary.categories["Health Activities"] = weekActivities.filter(a => a.category === 'Health').length;
      weekSummary.categories["Household Activities"] = weekActivities.filter(a => a.category === 'Household').length;

  }


  if (!weekSummary || weekActivities.length === 0) { // Check if activities were found
     Logger.log("No activities found for the past week. No threshold bonuses calculated.");
     return { earnedBonuses: [], totalBonusPoints: 0 };
  }


  // Get bonus definitions
  const bonusDefinitions = getWeeklyThresholdBonuses();

  // Check each bonus definition
  bonusDefinitions.forEach(bonus => {
     // Check if the activity/category for the bonus exists in the game data
     let dataExists = true;
     if (bonus.specificActivity && activityData.pointValues[bonus.specificActivity] === undefined) {
        Logger.log(`Bonus "${bonus.name}" skipped: Activity "${bonus.specificActivity}" not found.`);
        dataExists = false;
     }
     if (bonus.category && !CONFIG.CATEGORIES.includes(bonus.category)) {
         Logger.log(`Bonus "${bonus.name}" skipped: Category "${bonus.category}" not defined in CONFIG.`);
        dataExists = false;
     }

     if(dataExists) {
        try { // Wrap countFunction call in try/catch
           // Pass weekActivities directly, countFunction should use it
           const count = bonus.countFunction(weekSummary, weekActivities, activityData);
           let qualifies = false;

           if (bonus.minCount !== undefined && count >= bonus.minCount) {
              qualifies = true;
           } else if (bonus.maxCount !== undefined && count <= bonus.maxCount) {
              qualifies = true;
           }

           if (qualifies) {
              Logger.log(`Bonus Qualified: "${bonus.name}" (Count: ${count})`);
              earnedBonuses.push({
                 id: bonus.id,
                 name: bonus.name,
                 description: bonus.description,
                 bonusPoints: bonus.bonusPoints,
                 count: count // Include the count that qualified
              });
              totalBonusPoints += bonus.bonusPoints;
           }
        } catch (countErr) {
            Logger.log(`Error executing countFunction for bonus "${bonus.name}": ${countErr}`);
        }
     }
  });

  Logger.log(`Total threshold bonus points calculated for past week: ${totalBonusPoints}`);
  return {
    earnedBonuses: earnedBonuses,
    totalBonusPoints: totalBonusPoints
  };
}

/**
 * Helper to calculate a summary object structure from a list of activities.
 * Used when a weekly sheet doesn't exist or for bonus calculation based on detailed list.
 * @param {Array<object>} activities - Array from getWeekActivities { name, points, date, category }.
 * @param {object} activityData - Cached activity data {pointValues, categories}.
 * @return {object} Summary object { total, positive, negative, topActivity, topActivityCount, categories: { ... } }
 */
function calculateSummaryFromActivities(activities, activityData) {
    let total = 0;
    let positive = 0; // Count of positive activity entries
    let negative = 0; // Count of negative activity entries
    const activityCounts = {}; // Count occurrences of each specific activity name
    const categoryCounts = { // Mirroring weekly sheet summary structure G2:G5
        "Positive Activities": 0,
        "Negative Activities": 0,
        "Health Activities": 0,
        "Household Activities": 0
        // Add other categories based on weekly sheet setup if needed
    };

    activities.forEach(act => {
        total += act.points; // Sum the actual points recorded (which include streak bonuses)
        const category = act.category || "Unknown"; // Use category from getWeekActivities result
        activityCounts[act.name] = (activityCounts[act.name] || 0) + 1;

        // Count based on whether the specific entry had positive or negative points
        if (act.points >= 0) {
            positive++;
            categoryCounts["Positive Activities"]++;
            if (category === 'Health') categoryCounts["Health Activities"]++;
            if (category === 'Household') categoryCounts["Household Activities"]++;
            // Add other specific positive categories if tracked
        } else {
            negative++;
            categoryCounts["Negative Activities"]++;
            // Add specific negative categories if tracked
        }
    });

    let topActivity = "None";
    let topActivityCount = 0;
    for (const [name, count] of Object.entries(activityCounts)) {
        if (count > topActivityCount) {
            topActivityCount = count;
            topActivity = name;
        }
    }

    return { total, positive, negative, topActivity, topActivityCount, categories: categoryCounts };
}
