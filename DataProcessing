// DataProcessing.gs
/**
 * Reads activity data from the Points Reference sheet with improved error handling.
 * Returns an object containing pointValues and categories maps.
 * Uses CONFIG for sheet name.
 */
function readActivityData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetName = CONFIG.SHEET_NAMES.POINTS_REFERENCE;
  let sheet = ss.getSheetByName(sheetName);

  if (!sheet) {
    Logger.log(`${sheetName} not found, attempting to set up.`);
    setupPointsReferenceSheet(); // Try to create it
    sheet = ss.getSheetByName(sheetName); // Get it again
    if (!sheet) {
      Logger.log(`FATAL: Failed to create or find ${sheetName}. Cannot read activity data.`);
      // Return empty structure to prevent further errors down the line
      return { pointValues: {}, categories: {} };
    }
  }

  const lastRow = sheet.getLastRow();
  if (lastRow < 2) {
    Logger.log(`No activities found in ${sheetName}.`);
    return { pointValues: {}, categories: {} }; // Return empty if no data rows
  }

  try {
    const data = sheet.getRange(2, 1, lastRow - 1, 3).getValues();
    const pointValues = {};
    const categories = {};

    data.forEach(row => {
      const activity = String(row[0]).trim();
      const pointsValue = row[1];
      // Better validation for numeric values
      const points = typeof pointsValue === 'number' ? pointsValue : 
                    (pointsValue !== "" && !isNaN(pointsValue) ? Number(pointsValue) : NaN);
      const category = String(row[2]).trim();

      // Only add valid entries
      if (activity && !isNaN(points) && category) {
        pointValues[activity] = points;
        categories[activity] = category;
      } else {
        if (activity || !isNaN(points) || category) { // Log if *any* data was present but row was invalid
          Logger.log(`Skipping invalid row in ${sheetName}: [${JSON.stringify(row)}]`);
        }
      }
    });

    return { pointValues, categories };
  } catch (error) {
    Logger.log(`Error reading activity data: ${error}\nStack: ${error.stack}`);
    // Return an empty structure rather than throw, to prevent cascading failures
    return { pointValues: {}, categories: {} };
  }
}

/**
 * Caching wrapper for readActivityData with improved error handling.
 * Uses a script-global variable and CacheService.
 */
function getActivityDataCached() {
  // 1. Check script-global cache first (fastest for same execution)
  if (activityDataCache) {
    return activityDataCache;
  }

  // 2. Check CacheService (persists briefly across executions)
  try {
    const cache = CacheService.getScriptCache();
    const cachedJson = cache.get('activityData');
    if (cachedJson) {
      try {
        activityDataCache = JSON.parse(cachedJson);
        return activityDataCache;
      } catch (parseError) {
        Logger.log(`Error parsing activity data from CacheService: ${parseError}. Refetching.`);
        // Continue to fetch fresh data
      }
    }
  } catch (cacheError) {
    Logger.log(`Error accessing CacheService: ${cacheError}. Will use fresh data.`);
    // Continue to fetch fresh data
  }

  // 3. If no cache hit, read fresh data
  Logger.log("Cache miss. Reading fresh activity data from sheet.");
  const freshData = readActivityData();

  // Store in script cache but don't propagate errors
  activityDataCache = freshData;
  try {
    // Only cache if data is not empty and looks valid
    if (freshData && Object.keys(freshData.pointValues || {}).length > 0) {
      const cache = CacheService.getScriptCache();
      cache.put('activityData', JSON.stringify(freshData), CONFIG.CACHE_EXPIRATION_SECONDS);
    }
  } catch (e) {
    Logger.log(`Warning: Error saving activity data to CacheService: ${e}`);
  }

  return freshData;
}

/**
 * Processes a single activity string with improved error handling.
 * Extracts name, calculates points including streak bonus.
 * @param {string} activityString The string from the form response.
 * @param {object} activityData The cached activity data {pointValues, categories}.
 * @return {object} { name: string|null, points: number, category: string, streakInfo: object }
 */
function processActivityWithPoints(activityString, activityData) {
  if (!activityString) {
    return { 
      name: null, 
      points: 0, 
      category: "Unknown", 
      streakInfo: { originalPoints: 0, bonusPoints: 0, totalPoints: 0, streakLength: 0, multiplier: 1 } 
    };
  }

  // Validate activityData - use empty structures if missing
  const pointValues = (activityData && activityData.pointValues) ? activityData.pointValues : {};
  const categories = (activityData && activityData.categories) ? activityData.categories : {};

  let activityName = null;
  let basePoints = 0;
  let category = "Unknown";

  try {
    // Try extracting from "Activity Name (+P)" or "Activity Name (-P)" format
    // Robust regex allowing optional spaces
    const match = activityString.match(/(.*?)\s*\(([+-]\d+)\)\s*$/);

    if (match) {
      activityName = match[1].trim();
      // Important: Use points from the *sheet data* as the source of truth, not the string
      if (pointValues[activityName] !== undefined) {
        basePoints = pointValues[activityName];
        category = categories[activityName] || "Unknown";
      } else {
        // Activity name found in string, but not in Points Reference - log warning
        Logger.log(`Warning: Activity "${activityName}" from form response not found in Points Reference. Using 0 points.`);
        basePoints = 0; // Assign 0 points if not found
        category = "Uncategorized"; // Assign default category
      }
    } else {
      // If no (+P)/(-P) format, check if the whole string matches an activity name exactly
      activityName = activityString;
      if (pointValues[activityName] !== undefined) {
        basePoints = pointValues[activityName];
        category = categories[activityName] || "Unknown";
      } else {
        // Whole string doesn't match either - treat as unknown
        Logger.log(`Warning: Unrecognized activity string "${activityString}". Using 0 points.`);
        activityName = activityString; // Keep original string as name for logging
        basePoints = 0;
        category = "Uncategorized";
      }
    }

    // Calculate streak multiplier and bonus points ONLY for positive base points
    let streakInfo = {
      originalPoints: basePoints,
      bonusPoints: 0,
      totalPoints: basePoints,
      streakLength: 0,
      multiplier: 1
    };

    if (activityName && basePoints > 0) {
      // Ensure calculateStreakMultiplier exists and handles potential errors
      try {
        // Check if calculateStreakMultiplier exists before calling
        if (typeof calculateStreakMultiplier === "function") {
          streakInfo = calculateStreakMultiplier(activityName, basePoints);
        } else {
          Logger.log("Warning: calculateStreakMultiplier function not found. Skipping streak calculation.");
          streakInfo.totalPoints = basePoints; // Fallback to base points
        }
      } catch (streakError) {
        Logger.log(`Error calculating streak for ${activityName}: ${streakError}. Using base points only.`);
        streakInfo.totalPoints = basePoints; // Fallback to base points
      }
    } else {
      // For negative points or zero base points, totalPoints is just basePoints
      streakInfo.totalPoints = basePoints;
    }

    return {
      name: activityName,
      points: streakInfo.totalPoints, // Final calculated points
      category: category,
      streakInfo: streakInfo
    };
  } catch (error) {
    Logger.log(`Error processing activity "${activityString}": ${error}`);
    return { 
      name: activityString, // Keep the original string for debugging
      points: 0, // Fail safe to 0 points
      category: "Error", 
      streakInfo: { originalPoints: 0, bonusPoints: 0, totalPoints: 0, streakLength: 0, multiplier: 1 } 
    };
  }
}

/**
 * Processes a cell value that might contain multiple comma-separated activities.
 * Used during rebuild from responses sheet AND by getWeekActivities.
 * @param {string} cellValue The value from the spreadsheet cell.
 * @return {object} { points: number, activities: Array<object> }
 */
function processCheckboxCell(cellValue) {
  let totalPoints = 0;
  const activities = []; // Array to hold { name, points, category, streakInfo }

  if (!cellValue || typeof cellValue !== 'string') {
    return { points: 0, activities: [] };
  }

  const activityData = getActivityDataCached(); // Use cached data
  const selectedOptions = cellValue.split(', '); // Assumes ", " delimiter

  selectedOptions.forEach(option => {
    const trimmedOption = option.trim();
    if (trimmedOption) {
      const result = processActivityWithPoints(trimmedOption, activityData);
      // Add the detailed result object to the activities array
      if (result.name) { // Only add if it was a valid/processed activity
        activities.push({
            name: result.name,
            points: result.points, // Store the final points (incl. streak)
            category: result.category,
            streakInfo: result.streakInfo // Include streak info
        });
        totalPoints += result.points; // Sum points AFTER pushing details
      }
    }
  });

  return { points: totalPoints, activities: activities };
}


/**
 * Updates the dashboard sheet (A-G) with data from a single form submission.
 * Adds a new row if date doesn't exist, otherwise updates existing row for that user/date.
 * Includes streak indicator (ðŸ”¥X) in the activity string.
 * @param {Date} timestamp The timestamp of the submission.
 * @param {string} email The respondent's email.
 * @param {Array<object>} activities An array of processed activity objects { name, points, category, streakInfo }.
 * @param {number} totalPoints The total points for this submission.
 */
function updateDashboard(timestamp, email, activities, totalPoints) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
  if (!dashboardSheet) {
     Logger.log("Dashboard sheet not found in updateDashboard.");
     setupDashboard(); // Try to create it if missing
     dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
     if (!dashboardSheet) {
         Logger.log("FATAL: Could not find or create Dashboard sheet. Update failed.");
         return;
     }
  }

  if (!(timestamp instanceof Date)) timestamp = new Date(timestamp);
  const formattedDate = formatDateYMD(timestamp); // YYYY-MM-DD for comparison
  const weekNum = getISOWeekNumber(timestamp); // Use utility function

  let rowIndex = -1;
  const lastRow = dashboardSheet.getLastRow();

  // Find existing row for the specific user and date (more robust update)
  if (lastRow > 1) {
     // Get Date (Col A) and Email (Col G)
     const data = dashboardSheet.getRange(2, 1, lastRow - 1, 7).getValues(); // A2:G<lastRow>
     for (let i = data.length - 1; i >= 0; i--) { // Search backward
        const rowData = data[i];
        const cellDate = rowData[0];
        const cellEmail = rowData[6] || ""; // Email in Col G (index 6)

        if (cellDate instanceof Date && cellDate.getTime() > 0) {
           if (formatDateYMD(cellDate) === formattedDate && cellEmail.toLowerCase() === email.toLowerCase()) {
              rowIndex = i + 2; // +2 because data starts at row 2, loop index is 0-based
              break;
           }
        }
     }
  }

  // Prepare activity string and counts
  let positiveCountDelta = 0;
  let negativeCountDelta = 0;
  const activityStrings = activities.map(activity => {
    const symbol = activity.points >= 0 ? "âž•" : "âž–";
    const formattedPts = activity.points >= 0 ? `+${activity.points}` : activity.points;
    // Count based on original base points before multiplier/bonus
    if (activity.streakInfo && activity.streakInfo.originalPoints > 0) positiveCountDelta++;
    if (activity.streakInfo && activity.streakInfo.originalPoints < 0) negativeCountDelta++;

    // Include streak info visually if streak exists (>= 2 days)
    let streakText = "";
    if (activity.streakInfo && activity.streakInfo.streakLength >= 2) { // Show for building streaks too
        streakText = ` (ðŸ”¥${activity.streakInfo.streakLength})`;
    }
    return `${symbol} ${activity.name}${streakText} (${formattedPts})`;
  });
  const newActivitiesString = activityStrings.join(", ");

  if (rowIndex === -1) {
    // Add new row
    rowIndex = lastRow + 1;
    const newRowData = [
       timestamp,           // Col A: Date
       totalPoints,         // Col B: Points
       newActivitiesString, // Col C: Activities
       positiveCountDelta,  // Col D: Positive Count
       negativeCountDelta,  // Col E: Negative Count
       weekNum,             // Col F: Week Number
       email                // Col G: Email
    ];
    // Ensure the target row exists before setting values
    if (rowIndex > dashboardSheet.getMaxRows()) {
        dashboardSheet.insertRowAfter(dashboardSheet.getMaxRows());
    }
    dashboardSheet.getRange(rowIndex, 1, 1, newRowData.length).setValues([newRowData]);
    // Apply formatting to the new row immediately (optional but nice)
    dashboardSheet.getRange(rowIndex, 1).setNumberFormat(CONFIG.DATE_FORMAT_SHORT);
    dashboardSheet.getRange(rowIndex, 2).setNumberFormat(CONFIG.POINTS_FORMAT);
    // Apply alternating row color if needed (can be done via conditional formatting setup)

  } else {
    // Update existing row for this user and date
    const pointsCell = dashboardSheet.getRange(rowIndex, 2);
    const activitiesCell = dashboardSheet.getRange(rowIndex, 3);
    const posCountCell = dashboardSheet.getRange(rowIndex, 4);
    const negCountCell = dashboardSheet.getRange(rowIndex, 5);
    // WeekNum (Col F) and Email (Col G) should already be correct

    const existingPoints = pointsCell.getValue() || 0;
    const existingActivities = activitiesCell.getValue() || "";
    const existingPosCount = posCountCell.getValue() || 0;
    const existingNegCount = negCountCell.getValue() || 0;

    pointsCell.setValue(existingPoints + totalPoints);
    // Append new activities, handling empty existing string
    activitiesCell.setValue(existingActivities ? `${existingActivities}, ${newActivitiesString}` : newActivitiesString);
    posCountCell.setValue(existingPosCount + positiveCountDelta);
    negCountCell.setValue(existingNegCount + negativeCountDelta);
  }

  // Removed calls to updateWeeklyTotals and chart generation as they are either removed or handled client-side
  // Removed call to createOrUpdateWeeklySheet
}


/**
 * Calculates the current week's summary totals for a SPECIFIC HOUSEHOLD by reading the Dashboard sheet.
 * Used by the Web App's getWeekData function.
 * @param {Array<string>} householdEmails - Array of email addresses for the household.
 * @return {object} Summary object { total, positive, negative, topActivity, topActivityCount, categories }
 */
function getHouseholdWeeklyTotals(householdEmails) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
  const defaultSummary = {
    total: 0, positive: 0, negative: 0, topActivity: "None", topActivityCount: 0,
    // Simplified categories map, can be expanded if needed by client
    categories: { "Total Positive": 0, "Total Negative": 0 }
  };

  if (!dashboardSheet) {
    Logger.log("Dashboard sheet not found in getHouseholdWeeklyTotals.");
    return defaultSummary;
  }
  if (!householdEmails || householdEmails.length === 0) {
    Logger.log("No household emails provided to getHouseholdWeeklyTotals.");
    return defaultSummary; // Cannot filter without emails
  }

  const today = new Date();
  const startOfWeek = getWeekStartDate(today);
  const endOfWeek = getWeekEndDate(today);
  const startDateStr = formatDateYMD(startOfWeek);
  const endDateStr = formatDateYMD(endOfWeek);

  let weeklyTotal = 0;
  let weeklyPositiveCount = 0;
  let weeklyNegativeCount = 0;
  const activityCounts = {}; // For finding top activity

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow < 2) {
     return defaultSummary;
  }

  // Read Dashboard: Date(A), Points(B), Activities(C), PosCount(D), NegCount(E), Email(G)
  const data = dashboardSheet.getRange(2, 1, lastRow - 1, 7).getValues(); // A2:G<lastRow>

  data.forEach(row => {
    const date = row[0];
    const rowEmail = row[6] || ""; // Email in Col G

    if (date instanceof Date) {
        const dateStr = formatDateYMD(date);
        // Check if date is in current week AND email matches household
        if (dateStr >= startDateStr && dateStr <= endDateStr &&
            householdEmails.some(email => email.toLowerCase() === rowEmail.toLowerCase()))
        {
          const points = Number(row[1]) || 0;
          const activitiesString = row[2] || "";
          const posCount = Number(row[3]) || 0; // Use the stored counts directly
          const negCount = Number(row[4]) || 0; // Use the stored counts directly

          weeklyTotal += points;
          weeklyPositiveCount += posCount;
          weeklyNegativeCount += negCount;

          // Tally top activity based on the activity string
          if (activitiesString) {
            const activitiesList = activitiesString.split(", ");
            activitiesList.forEach(activityEntry => {
              // Use robust regex to extract activity name
              const match = activityEntry.match(/[âž•âž–]\s(.+?)\s(\(ðŸ”¥\d+\))?\s\([+-]/);
              if (match && match[1]) {
                const activityName = match[1].trim();
                activityCounts[activityName] = (activityCounts[activityName] || 0) + 1;
              }
            });
          }
        }
    }
  });

  // Find top activity
  let topActivityName = "None";
  let maxCount = 0;
  for (const activity in activityCounts) {
    if (activityCounts[activity] > maxCount) {
      maxCount = activityCounts[activity];
      topActivityName = activity;
    }
  }

  // Return the calculated data
   return {
    total: weeklyTotal,
    positive: weeklyPositiveCount,
    negative: weeklyNegativeCount,
    topActivity: topActivityName,
    topActivityCount: maxCount,
    categories: {
        "Total Positive": weeklyPositiveCount,
        "Total Negative": weeklyNegativeCount
        // Add more specific category counts here if needed by iterating activities again
    }
  };
}

/**
 * Reads activities from the Dashboard sheet for a specific date range and optional household filter.
 * @param {Date} startDate The start date of the range (inclusive).
 * @param {Date} endDate The end date of the range (inclusive).
 * @param {Array<string>} [householdEmails] Optional array of emails to filter results by household.
 * @return {Array<object>} An array of activity objects { name, points, date, email, category, streakInfo }.
 */
function getWeekActivities(startDate, endDate, householdEmails) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
    const allActivities = [];

    if (!dashboardSheet) {
        Logger.log(`ERROR: Dashboard sheet "${CONFIG.SHEET_NAMES.DASHBOARD}" not found in getWeekActivities.`);
        return [];
    }

    const lastRow = dashboardSheet.getLastRow();
    if (lastRow < 2) {
        Logger.log("No data in Dashboard sheet.");
        return [];
    }

    // Read Dashboard: Date(A), Points(B), Activities(C), PosCount(D), NegCount(E), Email(G)
    const data = dashboardSheet.getRange(2, 1, lastRow - 1, 7).getValues(); // A2:G<lastRow>
    const activityData = getActivityDataCached(); // Get points/categories map

    const startDateStr = formatDateYMD(startDate);
    const endDateStr = formatDateYMD(endDate);

    Logger.log(`Processing ${data.length} Dashboard rows for activities between ${startDateStr} and ${endDateStr}.${householdEmails ? ` Filtering for ${householdEmails.length} household members.` : ''}`);

    data.forEach((row, rowIndex) => {
        const timestamp = row[0]; // Date object from Col A
        const rowEmail = row[6] || "Unknown"; // Email from Col G

        // Check if timestamp is valid and within the desired range
        if (timestamp instanceof Date && timestamp.getTime() > 0) {
            const dateStr = formatDateYMD(timestamp);
            if (dateStr >= startDateStr && dateStr <= endDateStr) {
                // --- Household Filtering ---
                let includeRow = true;
                if (householdEmails && householdEmails.length > 0) {
                    if (!rowEmail || rowEmail === "Unknown" || !householdEmails.some(he => he.toLowerCase() === rowEmail.toLowerCase())) {
                        includeRow = false;
                    }
                }
                // --- End Household Filtering ---

                if (includeRow) {
                    const activitiesStr = row[2] || ""; // Activities string from Col C
                    if (activitiesStr) {
                        const activitiesList = activitiesStr.split(", ");
                        activitiesList.forEach(activityEntry => {
                            // Use processActivityWithPoints to parse and calculate points/streaks for EACH entry
                            // Note: processActivityWithPoints expects the *base* activity name or name(+/-P) format
                            // We need to extract the base name from the log string first
                            const match = activityEntry.match(/[âž•âž–]\s(.+?)\s*(?:\(ðŸ”¥\d+\))?\s*\(/);
                            if (match && match[1]) {
                                const activityName = match[1].trim();
                                // Re-process using the name to get accurate points/category/streak for THAT instance
                                const result = processActivityWithPoints(activityName, activityData);
                                if (result.name) { // Ensure it's a valid activity
                                    allActivities.push({
                                        name: result.name,
                                        points: result.points, // Points incl. streak
                                        date: timestamp,
                                        email: rowEmail,
                                        category: result.category,
                                        streakInfo: result.streakInfo
                                    });
                                }
                            }
                        }); // End loop through activities in cell
                    } // End if activitiesStr
                } // End includeRow check
            } // End date range check
        } // End valid date check
    }); // End row loop

    Logger.log(`Finished processing Dashboard. Found ${allActivities.length} relevant activities.`);
    return allActivities;
}


/**
 * Calculates summary statistics from an array of activities.
 * @param {Array} activities - Array of activity objects { name, points, date, email, category?, streakInfo? }.
 * @param {object} activityData - Cache of activity data (optional)
 * @return {Object} Summary object with counts and totals
 */
function calculateSummaryFromActivities(activities, activityData = null) {
  if (!Array.isArray(activities) || activities.length === 0) {
    return {
      total: 0, positive: 0, negative: 0, topActivity: "None", topActivityCount: 0,
      categories: { "Total Positive": 0, "Total Negative": 0, "Health Activities": 0, "Household Activities": 0 }
    };
  }

  if (!activityData) {
    activityData = getActivityDataCached();
  }

  let totalPoints = 0;
  let positiveCount = 0; // Count of positive activity entries
  let negativeCount = 0; // Count of negative activity entries
  const activityCounts = {}; // Count occurrences of each specific activity name
  const categoryCounts = { // Mirroring weekly sheet summary structure G2:G5
      "Total Positive": 0, "Total Negative": 0, "Health Activities": 0, "Household Activities": 0
      // Add other specific categories if tracked in CONFIG
  };
  // Initialize other categories from CONFIG
  CONFIG.CATEGORIES.forEach(cat => {
     if (!categoryCounts[`${cat} Activities`]) { // Avoid overwriting defaults
        categoryCounts[`${cat} Activities`] = 0;
     }
  });


  activities.forEach(act => {
    totalPoints += act.points; // Sum the actual points recorded (which include streak bonuses)
    const category = act.category || activityData.categories[act.name] || "Unknown"; // Use provided category or look up
    activityCounts[act.name] = (activityCounts[act.name] || 0) + 1;

    // Count based on whether the specific entry had positive or negative points
    if (act.points >= 0) {
      positiveCount++;
      categoryCounts["Total Positive"]++;
    } else {
      negativeCount++;
      categoryCounts["Total Negative"]++;
    }
    // Increment specific category count
     const categoryKey = `${category} Activities`;
     if (categoryCounts.hasOwnProperty(categoryKey)) { // Check if we track this category
         categoryCounts[categoryKey]++;
     }
  });

  let topActivity = "None";
  let topActivityCount = 0;
  for (const [name, count] of Object.entries(activityCounts)) {
    if (count > topActivityCount) {
      topActivityCount = count;
      topActivity = name;
    }
  }

  // Filter out categories with 0 counts before returning? Optional.
  // const filteredCategoryCounts = {};
  // for (const [key, count] of Object.entries(categoryCounts)) {
  //    if (count > 0) filteredCategoryCounts[key] = count;
  // }

  return { total: totalPoints, positive: positiveCount, negative: negativeCount, topActivity: topActivity, topActivityCount: topActivityCount, categories: categoryCounts /*filteredCategoryCounts*/ };
}

/**
 * Gets historical data for visualizations with household filtering from Dashboard.
 * @return {Object} Data for charts including daily and weekly trends.
 */
function getHistoricalData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
  const defaultResult = {
    success: false, message: "Dashboard sheet not found", dailyData: [], weeklyData: [],
    streakData: { buildingStreaks: {}, streaks: {} }, movingAverages: [],
    lifetimeActivityCounts: {}, prevWeekActivityCounts: {}, householdId: null, householdName: null
  };

  if (!dashboardSheet) {
    return defaultResult;
  }

  // Get current user's email and household
  const email = Session.getEffectiveUser().getEmail();
  const householdId = getUserHouseholdId(email);
  let householdEmails = [];
  if (householdId) {
    householdEmails = getHouseholdEmails(householdId);
  } else {
    householdEmails = [email]; // Use individual email if no household
  }
  Logger.log(`getHistoricalData: Fetching for household members: ${householdEmails.join(', ')}`);

  // Get daily data from dashboard, aggregated for the household
  const lastRow = dashboardSheet.getLastRow();
  const dailyDataMap = new Map(); // Use map for aggregation { dateStr: { date, displayDate, points } }

  if (lastRow > 1) {
    // Read Dashboard: Date(A), Points(B), Email(G)
    const data = dashboardSheet.getRange(2, 1, lastRow - 1, 7).getValues(); // A2:G<lastRow>
    const timezone = Session.getScriptTimeZone();

    data.forEach(row => {
      const dateObj = row[0];
      const rowEmail = row[6] || ""; // Email in Col G

      if (dateObj instanceof Date && dateObj.getTime() > 0 &&
          householdEmails.some(he => he.toLowerCase() === rowEmail.toLowerCase()))
      {
        const dateStr = formatDateYMD(dateObj);
        const points = Number(row[1]) || 0;

        if (!dailyDataMap.has(dateStr)) {
          dailyDataMap.set(dateStr, {
            date: dateStr,
            displayDate: Utilities.formatDate(dateObj, timezone, "MMM d"), // Format for charts
            points: 0
          });
        }
        dailyDataMap.get(dateStr).points += points;
      }
    });
  }
  const dailyData = Array.from(dailyDataMap.values()).sort((a, b) => a.date.localeCompare(b.date));

  // Get weekly data aggregated from daily data
  const weeklyDataMap = new Map(); // { weekStartDateStr: { startDate, displayDate, totalPoints, ... } }
  dailyData.forEach(day => {
      const weekStartDate = getWeekStartDate(new Date(day.date + 'T00:00:00')); // Ensure correct date parsing
      const weekStartDateStr = formatDateYMD(weekStartDate);
      if (!weeklyDataMap.has(weekStartDateStr)) {
          weeklyDataMap.set(weekStartDateStr, {
              startDate: weekStartDateStr,
              displayDate: Utilities.formatDate(weekStartDate, Session.getScriptTimeZone(), "MMM d, yyyy"),
              totalPoints: 0,
              positiveCount: 0, // Need to recalculate these based on daily activities if required by charts
              negativeCount: 0,
              dailyBreakdown: { sunday: 0, monday: 0, tuesday: 0, wednesday: 0, thursday: 0, friday: 0, saturday: 0 }
          });
      }
      const weekEntry = weeklyDataMap.get(weekStartDateStr);
      weekEntry.totalPoints += day.points;
      // Populate dailyBreakdown based on the day's date
      const dayOfWeek = new Date(day.date + 'T00:00:00').getDay(); // 0=Sun, 6=Sat
       const dayKeys = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
       weekEntry.dailyBreakdown[dayKeys[dayOfWeek]] += day.points;
       // Note: Getting accurate Pos/Neg counts per week requires reading the daily activity strings again here,
       // which might be slow. Simplified weeklyData structure for now. Modify if needed.
  });
  const weeklyData = Array.from(weeklyDataMap.values()).sort((a, b) => a.startDate.localeCompare(b.startDate));


  // Get streak data for the household
  let streakData = { buildingStreaks: {}, streaks: {} };
  try {
     if (householdId && typeof trackActivityStreaksForHousehold === "function") {
        streakData = trackActivityStreaksForHousehold(householdId) || { buildingStreaks: {}, streaks: {} };
     } else if (typeof trackActivityStreaks === "function"){
        streakData = trackActivityStreaks(); // Fallback for non-household or missing function
     }
  } catch (e) { Logger.log(`Error getting streak data: ${e}`); }

  // Calculate moving average for daily points
  const movingAverages = calculateMovingAverages(dailyData, 7);

  // Get lifetime and previous week counts (these currently don't filter by household, adjust if needed)
  const lifetimeCounts = getEnhancedLifetimeActivityCounts(householdEmails);
  const prevWeekCounts = getEnhancedPreviousWeekActivityCounts(householdEmails);


  return {
    success: true,
    dailyData: dailyData,
    weeklyData: weeklyData,
    streakData: streakData,
    movingAverages: movingAverages,
    lifetimeActivityCounts: lifetimeCounts,
    prevWeekActivityCounts: prevWeekCounts,
    householdId: householdId,
    householdName: householdId ? getHouseholdName(householdId) : null
  };
}

/**
 * Calculates moving averages from daily data.
 * @param {Array<object>} dailyData Array of objects { date: string, points: number, ... }.
 * @param {number} window Number of days for the moving average window.
 * @return {Array<object>} Array of objects { date: string, average: number }.
 */
function calculateMovingAverages(dailyData, window) {
  const movingAverages = [];
  if (!dailyData || dailyData.length < window) {
    return dailyData.map(d => ({ date: d.date, displayDate: d.displayDate, average: null })); // Return nulls if not enough data
  }

  let sum = 0;
  // Calculate sum for the initial window
  for (let i = 0; i < window; i++) {
    sum += dailyData[i].points;
    // Add initial nulls for days before the first full window
    movingAverages.push({ date: dailyData[i].date, displayDate: dailyData[i].displayDate, average: null });
  }

  // Calculate the first average (index window - 1)
  movingAverages[window - 1].average = Math.round((sum / window) * 10) / 10;

  // Calculate subsequent averages using sliding window
  for (let i = window; i < dailyData.length; i++) {
    sum = sum - dailyData[i - window].points + dailyData[i].points;
    movingAverages.push({
        date: dailyData[i].date,
        displayDate: dailyData[i].displayDate,
        average: Math.round((sum / window) * 10) / 10
    });
  }

  return movingAverages;
}


/**
 * Gets lifetime activity counts by reading the Dashboard sheet.
 * @return {Object} Map of activity names to count and positive/negative status { activityName: { count: number, positive: boolean } }.
 */
function getLifetimeActivityCounts() {
  const activityData = getActivityDataCached();
  const activityCounts = {};
  // Initialize counts from reference
  for (const activityName in activityData.pointValues) {
    activityCounts[activityName] = { count: 0, positive: activityData.pointValues[activityName] > 0 };
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
  if (!dashboardSheet) return activityCounts;

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow <= 1) return activityCounts;

  // Read only the Activities column (C)
  const activitiesColumn = dashboardSheet.getRange(2, 3, lastRow - 1, 1).getValues();

  activitiesColumn.forEach(row => {
    const activitiesStr = row[0] || "";
    if (activitiesStr) {
      const activitiesList = activitiesStr.split(", ");
      activitiesList.forEach(activityEntry => {
        // Use robust regex matching
        const match = activityEntry.match(/[âž•âž–]\s(.+?)\s(\(ðŸ”¥\d+\))?\s\([+-]/);
        if (match && match[1]) {
          const activityName = match[1].trim();
          if (activityCounts[activityName]) { // Check if it's a known activity
            activityCounts[activityName].count++;
          }
        }
      });
    }
  });

  return activityCounts;
}

/**
 * Gets enhanced lifetime activity counts with household filtering.
 * @param {Array<string>} householdEmails - Array of household member emails
 * @return {Object} Map of activity names to count and positive/negative status
 */
function getEnhancedLifetimeActivityCounts(householdEmails) {
  const activityData = getActivityDataCached();
  const activityCounts = {};
  // Initialize counts from reference
  for (const activityName in activityData.pointValues) {
    activityCounts[activityName] = { 
      count: 0, 
      positive: activityData.pointValues[activityName] > 0 
    };
  }

  if (!householdEmails || householdEmails.length === 0) {
    Logger.log("No household emails provided for lifetime activity count filtering");
    return activityCounts;
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
  if (!dashboardSheet) return activityCounts;

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow <= 1) return activityCounts;

  // Read Activities column (C) and Email column (G)
  const data = dashboardSheet.getRange(2, 1, lastRow - 1, 7).getValues();
  
  let activityFound = false;
  data.forEach(row => {
    const activitiesStr = row[2] || ""; // Activities in column C
    const rowEmail = row[6] || "";      // Email in column G
    
    // Check if email is in household
    if (householdEmails.some(email => email.toLowerCase() === rowEmail.toLowerCase())) {
      if (activitiesStr) {
        const activitiesList = activitiesStr.split(", ");
        activitiesList.forEach(activityEntry => {
          // Use robust regex matching
          const match = activityEntry.match(/[âž•âž–]\s(.+?)\s*(?:\(ðŸ”¥\d+\))?\s*\([+-]/);
          if (match && match[1]) {
            const activityName = match[1].trim();
            if (activityCounts[activityName]) { // Check if it's a known activity
              activityCounts[activityName].count++;
              activityFound = true;
            }
          }
        });
      }
    }
  });
  
  // Add a flag to indicate if any activities were found
  activityCounts._hasData = activityFound;
  return activityCounts;
}

/**
 * Gets activity counts for the previous week by reading the Dashboard sheet.
 * @return {Object} Map of activity names to count and positive/negative status.
 */
function getPreviousWeekActivityCounts() {
  const activityData = getActivityDataCached();
  const activityCounts = {};
  // Initialize counts
  for (const activityName in activityData.pointValues) {
    activityCounts[activityName] = { count: 0, positive: activityData.pointValues[activityName] > 0 };
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
  if (!dashboardSheet) return activityCounts;

  // Calculate previous week's dates more precisely
  const today = new Date();
  const currentWeekStart = getWeekStartDate(today);
  
  // Go back 7 days from current week start to get previous week's start
  const prevWeekStart = new Date(currentWeekStart);
  prevWeekStart.setDate(prevWeekStart.getDate() - 7);
  
  // End date is 6 days after start (full week)
  const prevWeekEnd = new Date(prevWeekStart);
  prevWeekEnd.setDate(prevWeekEnd.getDate() + 6);
  prevWeekEnd.setHours(23, 59, 59, 999);  // End of the day

  const startDateStr = formatDateYMD(prevWeekStart);
  const endDateStr = formatDateYMD(prevWeekEnd);
  Logger.log(`Getting prev week counts for ${startDateStr} to ${endDateStr}`);

  // Get the current user's email and household
  const email = Session.getEffectiveUser().getEmail();
  const householdId = getUserHouseholdId(email);
  let householdEmails = householdId ? getHouseholdEmails(householdId) : [email];

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow <= 1) return activityCounts;

  // Read Date (A) and Activities (C) columns, and Email (G)
  const data = dashboardSheet.getRange(2, 1, lastRow - 1, 7).getValues(); // A2:G<lastRow>

  let activityFound = false;
  data.forEach(row => {
    const dateObj = row[0];
    const rowEmail = row[6] || "";
    
    // Filter by household
    if (dateObj instanceof Date && dateObj.getTime() > 0 && 
        householdEmails.some(email => email.toLowerCase() === rowEmail.toLowerCase())) {
      
      const dateStr = formatDateYMD(dateObj);
      // Check if date falls within the previous week
      if (dateStr >= startDateStr && dateStr <= endDateStr) {
        const activitiesStr = row[2] || ""; // Activities string
        if (activitiesStr) {
          const activitiesList = activitiesStr.split(", ");
          activitiesList.forEach(activityEntry => {
            const match = activityEntry.match(/[âž•âž–]\s(.+?)\s*(?:\(ðŸ”¥\d+\))?\s*\([+-]/);
            if (match && match[1]) {
              const activityName = match[1].trim();
              if (activityCounts[activityName]) {
                activityCounts[activityName].count++;
                activityFound = true;
              }
            }
          });
        }
      }
    }
  });
  
  // Add a flag to indicate if any activities were found
  activityCounts._hasData = activityFound;
  return activityCounts;
}

/**
 * Gets enhanced previous week activity counts with household filtering.
 * @param {Array<string>} householdEmails - Array of household member emails
 * @return {Object} Map of activity names to count and positive/negative status
 */
function getEnhancedPreviousWeekActivityCounts(householdEmails) {
  const activityData = getActivityDataCached();
  const activityCounts = {};
  // Initialize counts
  for (const activityName in activityData.pointValues) {
    activityCounts[activityName] = { 
      count: 0, 
      positive: activityData.pointValues[activityName] > 0 
    };
  }

  if (!householdEmails || householdEmails.length === 0) {
    Logger.log("No household emails provided for previous week activity count filtering");
    return activityCounts;
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
  if (!dashboardSheet) return activityCounts;

  // Calculate previous week's dates more precisely
  const today = new Date();
  const currentWeekStart = getWeekStartDate(today);
  
  // Go back 7 days from current week start to get previous week's start
  const prevWeekStart = new Date(currentWeekStart);
  prevWeekStart.setDate(prevWeekStart.getDate() - 7);
  
  // End date is 6 days after start (full week)
  const prevWeekEnd = new Date(prevWeekStart);
  prevWeekEnd.setDate(prevWeekEnd.getDate() + 6);
  prevWeekEnd.setHours(23, 59, 59, 999);  // End of the day

  const startDateStr = formatDateYMD(prevWeekStart);
  const endDateStr = formatDateYMD(prevWeekEnd);
  Logger.log(`Getting enhanced prev week counts for ${startDateStr} to ${endDateStr}`);

  const lastRow = dashboardSheet.getLastRow();
  if (lastRow <= 1) return activityCounts;

  // Read Date (A), Activities (C), and Email (G)
  const data = dashboardSheet.getRange(2, 1, lastRow - 1, 7).getValues();

  let activityFound = false;
  data.forEach(row => {
    const dateObj = row[0];
    const rowEmail = row[6] || "";
    
    // Filter by household and date range
    if (dateObj instanceof Date && dateObj.getTime() > 0 && 
        householdEmails.some(email => email.toLowerCase() === rowEmail.toLowerCase())) {
      
      const dateStr = formatDateYMD(dateObj);
      // Check if date falls within the previous week
      if (dateStr >= startDateStr && dateStr <= endDateStr) {
        const activitiesStr = row[2] || ""; // Activities string
        if (activitiesStr) {
          const activitiesList = activitiesStr.split(", ");
          activitiesList.forEach(activityEntry => {
            const match = activityEntry.match(/[âž•âž–]\s(.+?)\s*(?:\(ðŸ”¥\d+\))?\s*\([+-]/);
            if (match && match[1]) {
              const activityName = match[1].trim();
              if (activityCounts[activityName]) {
                activityCounts[activityName].count++;
                activityFound = true;
              }
            }
          });
        }
      }
    }
  });
  
  // Add a flag to indicate if any activities were found
  activityCounts._hasData = activityFound;
  return activityCounts;
}

/**
 * Rebuilds the Dashboard sheet from Form Responses with improved batch processing.
 * USE WITH CAUTION - Clears existing Dashboard data first.
 * @return {boolean} Success or failure of the rebuild operation.
 */
function rebuildAllFromFormResponses() {
  // Reset cache at start of rebuild
  resetActivityDataCache();

  const ui = SpreadsheetApp.getUi();
  const response = ui.alert(
     'Confirm Rebuild',
     'This will clear and rebuild the Dashboard sheet (Columns A-G) from "Form Responses 1". This can take time and cannot be undone. Proceed?',
     ui.ButtonSet.YES_NO);

  if (response !== ui.Button.YES) {
    Logger.log("Rebuild cancelled by user.");
    return false;
  }

  Logger.log("Starting Dashboard rebuild process...");
  SpreadsheetApp.getActiveSpreadsheet().toast('Starting rebuild...', 'In Progress', -1); // Indefinite toast

  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const formSheetName = CONFIG.SHEET_NAMES.FORM_RESPONSES;
    const formSheet = ss.getSheetByName(formSheetName);
    const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);

    if (!formSheet) {
      Logger.log(`ERROR: Form Responses sheet "${formSheetName}" not found. Cannot rebuild.`);
      ui.alert(`Error: Form Responses sheet "${formSheetName}" not found. Rebuild aborted.`);
      SpreadsheetApp.getActiveSpreadsheet().toast(`Rebuild Failed: Form Responses sheet missing.`, 'Error', 10);
      return false;
    }
    
    if (!dashboardSheet) {
      Logger.log(`ERROR: Dashboard sheet "${CONFIG.SHEET_NAMES.DASHBOARD}" not found. Attempting to create.`);
      setupDashboard(); // Try to create it if missing
      const newDashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
      if (!newDashboardSheet) {
        Logger.log("FATAL: Could not create Dashboard sheet. Rebuild aborted.");
        ui.alert("Error: Could not create Dashboard sheet. Rebuild aborted.");
        SpreadsheetApp.getActiveSpreadsheet().toast('Rebuild Failed: Could not create Dashboard sheet', 'Error', 10);
        return false;
      }
    }

    // 1. Clear Dashboard Sheet (A2:G)
    Logger.log("Clearing Dashboard sheet...");
    const clearSuccess = clearDerivedSheets(); // Calls refined function
    if (!clearSuccess) {
      const continueResponse = ui.alert(
        'Warning',
        'Issues encountered during dashboard clearing. Continue with rebuild anyway?',
        ui.ButtonSet.YES_NO);
      
      if (continueResponse !== ui.Button.YES) {
        Logger.log("Rebuild cancelled after clearing issues.");
        SpreadsheetApp.getActiveSpreadsheet().toast('Rebuild cancelled by user after clearing issues', 'Cancelled', 10);
        return false;
      }
      // Proceed despite clearing issues if user confirms
      Logger.log("Continuing rebuild despite clearing issues...");
    }
    SpreadsheetApp.flush(); // Ensure sheet is cleared

    // 2. Get Form Data
    const lastRowResponses = formSheet.getLastRow();
    if (lastRowResponses <= 1) {
      Logger.log("No data found in Form Responses sheet. Rebuild finished (nothing to process).");
      SpreadsheetApp.getActiveSpreadsheet().toast('Rebuild Complete: No responses found.', 'Complete', 10);
      return true;
    }
    
    // Find Email column in Form Responses
    const headersResponses = formSheet.getRange(1, 1, 1, formSheet.getLastColumn()).getValues()[0];
    let emailColIndexResponses = -1;
    for (let i=0; i<headersResponses.length; i++) {
        const headerText = String(headersResponses[i] || "").toLowerCase();
        if (headerText.includes('email') || headerText === 'email address') {
            emailColIndexResponses = i;
            Logger.log(`Found email column at index ${i} with header "${headersResponses[i]}"`);
            break;
        }
    }
    
    if (emailColIndexResponses === -1) {
      Logger.log("Warning: Could not find email column in Form Responses. Will use 'Unknown' for all entries.");
    }

    // Determine batch size based on total row count
    // Use smaller batches for very large datasets to avoid timeouts
    const totalRows = lastRowResponses - 1; // Excluding header
    let batchSize;
    if (totalRows > 1000) {
      batchSize = 200;
    } else if (totalRows > 500) {
      batchSize = 100;
    } else if (totalRows > 100) {
      batchSize = 50;
    } else {
      batchSize = 25;
    }
    Logger.log(`Processing ${totalRows} form responses in batches of ${batchSize}`);

    const totalBatches = Math.ceil(totalRows / batchSize);
    let errorsDuringProcessing = 0;
    const dashboardRows = []; // Accumulate all rows to write in a single operation

    // Pre-cache activity data for better performance
    const activityData = getActivityDataCached();
    
    // 3. Process Form Responses in batches
    for (let batchNum = 0; batchNum < totalBatches; batchNum++) {
      const batchStartRow = 2 + (batchNum * batchSize); // Start from row 2 (after header)
      const currentBatchSize = Math.min(batchSize, totalRows - (batchNum * batchSize));
      
      // Update progress indicator
      SpreadsheetApp.getActiveSpreadsheet().toast(
        `Processing batch ${batchNum+1}/${totalBatches} (rows ${batchStartRow} to ${batchStartRow+currentBatchSize-1})`, 
        'Rebuild Progress', 
        -1
      );
      
      // Get this batch of data
      const formDataBatch = formSheet.getRange(
        batchStartRow, 
        1, 
        currentBatchSize, 
        formSheet.getLastColumn()
      ).getValues();
      
      // Process each row in this batch
      for (let rowIdx = 0; rowIdx < formDataBatch.length; rowIdx++) {
        const row = formDataBatch[rowIdx];
        const timestamp = row[0]; // Assuming Timestamp is column A

        if (!(timestamp instanceof Date) || timestamp.getTime() === 0) {
          Logger.log(`Skipping row ${batchStartRow + rowIdx}: Invalid timestamp.`);
          continue; // Skip rows with invalid timestamps
        }

        // Get email (if email column was found)
        let email = "Unknown";
        if (emailColIndexResponses !== -1 && row.length > emailColIndexResponses) {
          const rawEmail = row[emailColIndexResponses];
          email = (rawEmail && typeof rawEmail === 'string') ? rawEmail.trim() : "Unknown";
        }

        let rowTotalPoints = 0;
        let rowActivities = [];
        let positiveCount = 0;
        let negativeCount = 0;

        // Process activity columns (skipping timestamp and email column)
        for (let col = 1; col < row.length; col++) {
          if (col === emailColIndexResponses) continue; // Skip email column
          
          const cellValue = row[col];
          // Improved validation - check for non-empty strings that aren't Yes/No
          if (cellValue && typeof cellValue === 'string' && 
              !['yes', 'no', 'true', 'false'].includes(cellValue.trim().toLowerCase())) {
            
            try {
              const cellResult = processCheckboxCell(cellValue);
              rowTotalPoints += cellResult.points;
              
              // Count activities by original points (not streak-adjusted)
              cellResult.activities.forEach(activity => {
                rowActivities.push(activity);
                if (activity.streakInfo && activity.streakInfo.originalPoints > 0) positiveCount++;
                if (activity.streakInfo && activity.streakInfo.originalPoints < 0) negativeCount++;
              });
            } catch (cellError) {
              Logger.log(`Error processing cell value "${cellValue}": ${cellError}`);
              errorsDuringProcessing++;
              // Continue processing other cells rather than skipping the whole row
            }
          }
        }

        // Create activity strings with streak info
        const activityStrings = rowActivities.map(activity => {
          const symbol = activity.points >= 0 ? "âž•" : "âž–";
          const formattedPts = activity.points >= 0 ? `+${activity.points}` : activity.points;
          
          let streakText = "";
          if (activity.streakInfo && activity.streakInfo.streakLength >= 2) {
            streakText = ` (ðŸ”¥${activity.streakInfo.streakLength})`;
          }
          
          return `${symbol} ${activity.name}${streakText} (${formattedPts})`;
        });
        
        const activitiesString = activityStrings.join(", ");
        const weekNum = getISOWeekNumber(timestamp);

        // Add this row to our accumulated array
        dashboardRows.push([
          timestamp, 
          rowTotalPoints, 
          activitiesString,
          positiveCount, 
          negativeCount, 
          weekNum, 
          email
        ]);
      }
      
      // Sleep briefly between batches to avoid script timeouts
      if (batchNum < totalBatches - 1) {
        Utilities.sleep(CONFIG.REBUILD_SLEEP_MS); 
      }
    }

    // 4. Write accumulated rows to Dashboard in one operation
    if (dashboardRows.length > 0) {
      Logger.log(`Writing ${dashboardRows.length} rows to Dashboard.`);
      SpreadsheetApp.getActiveSpreadsheet().toast(`Writing ${dashboardRows.length} rows to Dashboard...`, 'Rebuilding', -1);
      
      try {
        dashboardSheet.getRange(2, 1, dashboardRows.length, 7).setValues(dashboardRows);
        
        // Apply formatting after writing
        dashboardSheet.getRange("A2:A").setNumberFormat(CONFIG.DATE_FORMAT_SHORT);
        dashboardSheet.getRange("B2:B").setNumberFormat(CONFIG.POINTS_FORMAT);
        
        // Sort the sheet by date to ensure chronological order
        dashboardSheet.getRange(2, 1, dashboardRows.length, 7).sort({column: 1, ascending: true});
      } catch (writeError) {
        Logger.log(`Error writing to Dashboard: ${writeError}\nStack: ${writeError.stack}`);
        ui.alert(`Error writing data to Dashboard. ${dashboardRows.length} rows processed, but write failed. Check logs.`);
        SpreadsheetApp.getActiveSpreadsheet().toast('Rebuild Failed on Write: See Logs', 'Error', 10);
        return false;
      }
    }

    Logger.log(`Rebuild process completed. ${errorsDuringProcessing} errors occurred during processing.`);
    if(errorsDuringProcessing > 0) {
      SpreadsheetApp.getActiveSpreadsheet().toast(
        `Rebuild Complete with ${errorsDuringProcessing} errors. Check logs.`, 
        'Warning', 
        10
      );
    } else {
      SpreadsheetApp.getActiveSpreadsheet().toast('Dashboard Rebuild Complete!', 'Success', 10);
    }
    return true;

  } catch (error) {
    Logger.log(`CRITICAL ERROR during rebuild: ${error}\nStack: ${error.stack}`);
    ui.alert(`Rebuild failed due to a critical error: ${error.message}. Check script logs for details.`);
    SpreadsheetApp.getActiveSpreadsheet().toast('Rebuild Failed Critically! Check Logs.', 'Error', 10);
    return false;
  } finally {
    // Always clear cache when done to ensure fresh data
    resetActivityDataCache();
  }
}

/**
 * Clears data content (A2:G) from the Dashboard sheet with improved error handling.
 * @return {boolean} True if clearing was generally successful, false if major errors occurred.
 */
function clearDerivedSheets() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let overallSuccess = true;

  Logger.log("Clearing Dashboard sheet content (A2:G)...");

  try {
    const sheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);
    if (sheet) {
      const lastRow = sheet.getLastRow();
      if (lastRow > 1) {
        // Clear in smaller batches for large datasets
        const BATCH_SIZE = 1000;
        const totalRows = lastRow - 1;
        
        if (totalRows <= BATCH_SIZE) {
          // Small dataset - clear all at once
          sheet.getRange(2, 1, totalRows, 7).clearContent();
          Logger.log(`Cleared ${totalRows} rows from Dashboard.`);
        } else {
          // Large dataset - clear in batches
          const batches = Math.ceil(totalRows / BATCH_SIZE);
          
          for (let i = 0; i < batches; i++) {
            const startRow = 2 + (i * BATCH_SIZE);
            const rowsInBatch = Math.min(BATCH_SIZE, totalRows - (i * BATCH_SIZE));
            
            if (rowsInBatch > 0) {
              sheet.getRange(startRow, 1, rowsInBatch, 7).clearContent();
              Logger.log(`Cleared batch ${i+1}/${batches}: rows ${startRow} to ${startRow+rowsInBatch-1}`);
              // Brief pause between batches to prevent timeouts
              if (i < batches - 1) Utilities.sleep(100);
            }
          }
          Logger.log(`Cleared ${totalRows} rows from Dashboard in ${batches} batches.`);
        }
      } else {
        Logger.log(`Dashboard sheet has no content rows to clear.`);
      }
    } else {
      Logger.log(`Dashboard sheet not found during clear.`);
      overallSuccess = false; // Fail if Dashboard doesn't exist
    }
  } catch (e) {
    Logger.log(`Error clearing Dashboard: ${e}\nStack: ${e.stack}`);
    overallSuccess = false;
  }

  if (!overallSuccess) {
    Logger.log(`Dashboard clearing finished with errors.`);
  } else {
    Logger.log("Dashboard clearing process completed successfully.");
  }
  return overallSuccess;
}

// Add this function to DataProcessing.gs

/**
 * Gets raw data from Points Reference sheet, formatted for Admin UI.
 * Reads the sheet directly and returns an array of objects.
 * @return {Array<object>} Array of activities { activity, points, category }.
 */
function getPointsReferenceData() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(CONFIG.SHEET_NAMES.POINTS_REFERENCE);

  if (!sheet) {
    Logger.log("Points Reference sheet not found in getPointsReferenceData.");
    // Attempt to set up the sheet if it's missing
    setupPointsReferenceSheet();
    sheet = ss.getSheetByName(CONFIG.SHEET_NAMES.POINTS_REFERENCE); // Try again
    if (!sheet) {
       Logger.log("FATAL: Could not find or create Points Reference sheet after setup attempt.");
       return []; // Return empty if setup fails
    }
  }

  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) {
    return []; // Only header row exists
  }

  // Read all data rows (A:C)
  const data = sheet.getRange(2, 1, lastRow - 1, 3).getValues();

  // Map the raw data to the object structure expected by the Admin UI
  const formattedData = data.map(row => {
    const activityName = row[0] || "";
    let points = 0; // Default to 0
    // Check if points value is valid number
    if (row[1] !== "" && !isNaN(row[1])) {
        points = Number(row[1]);
    }
    const category = row[2] || ""; // Default to empty string

    return {
      activity: activityName,
      points: points,
      category: category
    };
  }).filter(item => item.activity !== ""); // Filter out any rows that might have become completely empty

  return formattedData;
}

// Add this function to DataProcessing.gs

/**
 * Gets historical goal achievement data across all weeks for a specific household or globally.
 * Reads the Dashboard sheet, aggregates weekly totals, and checks goal achievements.
 * @param {string} [householdId=null] Optional household ID to filter data. If null, uses all data for the calling user.
 * @return {Object} Data about goal achievements over time { weeklyTotals: [...], goalAchievements: {...} }.
 */
function calculateGoalAchievementHistory(householdId = null) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const dashboardSheet = ss.getSheetByName(CONFIG.SHEET_NAMES.DASHBOARD);

    // Default structure
    const result = {
      weeklyTotals: [],
      goalAchievements: {
        higherThanPrevious: { totalAchieved: 0, achievedWeeks: [] },
        doublePoints: { totalAchieved: 0, achievedWeeks: [] }
      }
    };

    if (!dashboardSheet) {
      Logger.log("Dashboard sheet not found in calculateGoalAchievementHistory.");
      return result;
    }

    // --- Get Household Emails if ID is provided ---
    let householdEmails = [];
    const currentUserEmail = Session.getEffectiveUser().getEmail(); // Use effective user for filtering if no household
    if (householdId && CONFIG.HOUSEHOLD_SETTINGS.ENABLED) {
        householdEmails = getHouseholdEmails(householdId); // From HouseholdManagement.gs
        if (!householdEmails || householdEmails.length === 0) {
            Logger.log(`No members found for household ${householdId} in goal history check.`);
            return result; // Return default if household has no members
        }
         Logger.log(`Calculating goal history for household members: ${householdEmails.join(', ')}`);
    } else {
        // If no household ID, calculate based on the single user accessing the app
        householdEmails = [currentUserEmail];
        Logger.log(`Calculating goal history for individual user: ${currentUserEmail}`);
    }
    // --- End Household Emails ---


    // --- Aggregate Weekly Totals from Dashboard ---
    const weeklyTotalsMap = new Map(); // { weekStartDateStr: totalPoints }
    const lastRow = dashboardSheet.getLastRow();

    if (lastRow > 1) {
      // Read Date(A), Points(B), Email(G)
      const data = dashboardSheet.getRange(2, 1, lastRow - 1, 7).getValues();

      data.forEach(row => {
        const dateObj = row[0];
        const rowEmail = row[6] || ""; // Email in Col G

        if (dateObj instanceof Date && dateObj.getTime() > 0) {
          // Filter row based on household/user emails
          if (householdEmails.some(he => he.toLowerCase() === rowEmail.toLowerCase())) {
            const points = Number(row[1]) || 0;
            const weekStartDate = getWeekStartDate(dateObj); // From Utilities.gs
            const weekStartDateStr = formatDateYMD(weekStartDate); // From Utilities.gs
            weeklyTotalsMap.set(weekStartDateStr, (weeklyTotalsMap.get(weekStartDateStr) || 0) + points);
          }
        }
      });
    }
    // --- End Aggregation ---

    if (weeklyTotalsMap.size === 0) {
         Logger.log("No relevant weekly data found on Dashboard for goal history calculation.");
         return result; // No data to process
    }


    // Convert map to array and sort weeks chronologically
    const weeklyData = Array.from(weeklyTotalsMap.entries()).map(([dateStr, total]) => ({
      startDateStr: dateStr,
      startDate: new Date(dateStr + 'T00:00:00'), // Ensure it's parsed as local date start
      total: total
    })).sort((a, b) => a.startDate - b.startDate);


    // Process weekly data to find goal achievements
    for (let i = 1; i < weeklyData.length; i++) { // Start from index 1 to compare with previous
      const currentWeek = weeklyData[i];
      const previousWeek = weeklyData[i - 1];

      // Format week start date for display
      const weekDateStr = Utilities.formatDate(currentWeek.startDate, Session.getScriptTimeZone(), "MMM d, yyyy");

      // Add to weekly totals array for the chart
      result.weeklyTotals.push({
        week: weekDateStr,
        total: currentWeek.total,
        previousTotal: previousWeek.total
      });

      // Check goal 1: Higher than previous week
      if (currentWeek.total > previousWeek.total) {
        result.goalAchievements.higherThanPrevious.totalAchieved++;
        result.goalAchievements.higherThanPrevious.achievedWeeks.push({
          week: weekDateStr,
          current: currentWeek.total,
          previous: previousWeek.total,
          improvement: currentWeek.total - previousWeek.total
        });
      }

      // Check goal 2: Double points from previous week (handle previous 0 or negative)
      const doubleTarget = previousWeek.total * 2;
      if ( (previousWeek.total > 0 && currentWeek.total >= doubleTarget) ||
           (previousWeek.total <= 0 && currentWeek.total > 0) ) // If previous was 0 or negative, any positive score is > double
      {
        result.goalAchievements.doublePoints.totalAchieved++;
        result.goalAchievements.doublePoints.achievedWeeks.push({
          week: weekDateStr,
          current: currentWeek.total,
          previous: previousWeek.total,
          multiplier: previousWeek.total !== 0 ? Math.round((currentWeek.total / previousWeek.total) * 10) / 10 : "âˆž"
        });
      }
    }

    Logger.log(`Goal achievement history calculated: Higher=${result.goalAchievements.higherThanPrevious.totalAchieved}, Double=${result.goalAchievements.doublePoints.totalAchieved}`);
    return result;

  } catch (error) {
    Logger.log(`Error in calculateGoalAchievementHistory: ${error}\nStack: ${error.stack}`);
    // Return minimal valid object on error
    return {
      weeklyTotals: [],
      goalAchievements: {
        higherThanPrevious: { totalAchieved: 0, achievedWeeks: [] },
        doublePoints: { totalAchieved: 0, achievedWeeks: [] }
      }
    };
  }
}
